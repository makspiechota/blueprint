import React from 'react';
import { AARRRMetrics, LeanViability } from '../parser/types';
import { calculateAllGaps, formatGap, isNegativeGap } from '../calculator/gap-calculator';

interface AARRRMetricsVisualizerProps {
  metrics: AARRRMetrics;
  viability?: LeanViability | null;
}

const AARRRMetricsVisualizer: React.FC<AARRRMetricsVisualizerProps> = ({ metrics, viability }) => {
  if (!metrics) {
    return <div className="container"><p>No AAARR metrics data available</p></div>;
  }

  let metricsWithGaps;
  try {
    metricsWithGaps = calculateAllGaps(metrics);
  } catch (error) {
    console.error('Error calculating gaps:', error);
    metricsWithGaps = metrics; // fallback to original data
  }

  return (
    <div className="container">
      <header>
        <h1>{metrics.title}</h1>
        <div className="meta">
          <span>Version: {metrics.version}</span>
          <span>Last Updated: {metrics.last_updated}</span>
        </div>
      </header>

      <div className="customer-factory">
        {renderPipeline(metricsWithGaps, viability)}
      </div>

      <footer>
        <p>Generated by BLUEPRINT - Business Layer Architecture</p>
      </footer>

      <style jsx>{`
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
          line-height: 1.6;
          color: #333;
          background: #f5f5f5;
          padding: 20px;
        }
        .container {
          max-width: 1400px;
          margin: 0 auto;
          background: white;
          border-radius: 8px;
          box-shadow: 0 2px 8px rgba(0,0,0,0.1);
          padding: 30px;
        }
        header {
          text-align: center;
          margin-bottom: 40px;
          border-bottom: 2px solid #e0e0e0;
          padding-bottom: 20px;
        }
        h1 { font-size: 2rem; color: #2c3e50; margin-bottom: 10px; }
        .meta { color: #7f8c8d; font-size: 0.9rem; }
        .customer-factory {
          display: flex;
          align-items: stretch;
          gap: 20px;
          margin: 30px 0;
          overflow-x: auto;
          padding: 20px 0;
        }
        .stage {
          flex: 1;
          min-width: 250px;
          border: 2px solid #e0e0e0;
          border-radius: 8px;
          padding: 20px;
          background: #fafafa;
          transition: all 0.3s;
        }
        .stage.has-gaps {
          border-color: #e74c3c;
          background: #fff5f5;
        }
        .stage.on-track {
          border-color: #27ae60;
          background: #f0fff4;
        }
        .stage-header {
          margin-bottom: 20px;
          border-bottom: 1px solid #ddd;
          padding-bottom: 10px;
        }
        .stage-header h2 {
          font-size: 1.3rem;
          color: #2c3e50;
          margin-bottom: 5px;
        }
        .stage-goal {
          font-size: 0.85rem;
          color: #7f8c8d;
          font-style: italic;
        }
        .connector {
          display: flex;
          align-items: center;
          font-size: 2rem;
          color: #95a5a6;
          font-weight: bold;
        }
        .metrics {
          display: flex;
          flex-direction: column;
          gap: 15px;
        }
        .metric {
          background: white;
          border: 1px solid #e0e0e0;
          border-radius: 6px;
          padding: 15px;
        }
        .metric.gap-exists {
          border-left: 4px solid #e74c3c;
        }
        .metric.on-track {
          border-left: 4px solid #27ae60;
        }
        .metric-name {
          font-weight: 600;
          color: #2c3e50;
          margin-bottom: 5px;
        }
        .metric-description {
          font-size: 0.85rem;
          color: #7f8c8d;
          margin-bottom: 10px;
        }
        .metric-values {
          display: flex;
          flex-direction: column;
          gap: 5px;
        }
        .value-row {
          display: flex;
          justify-content: space-between;
          font-size: 0.9rem;
        }
        .label {
          color: #7f8c8d;
          font-weight: 500;
        }
        .value {
          color: #2c3e50;
          font-weight: 600;
        }
        .gap-row {
          margin-top: 5px;
          padding-top: 5px;
          border-top: 1px solid #e0e0e0;
        }
        .gap-value.negative {
          color: #e74c3c;
          font-weight: bold;
        }
        .gap-value.positive {
          color: #27ae60;
          font-weight: bold;
        }
        footer {
          text-align: center;
          margin-top: 40px;
          padding-top: 20px;
          border-top: 1px solid #e0e0e0;
          color: #95a5a6;
          font-size: 0.85rem;
        }
        @media (max-width: 768px) {
          .customer-factory {
            flex-direction: column;
          }
          .connector {
            transform: rotate(90deg);
            margin: 10px 0;
          }
        }
      `}</style>
    </div>
  );
};

function renderPipeline(metrics: AARRRMetrics, viability: LeanViability | null): JSX.Element[] {
  const stages = ['acquisition', 'activation', 'retention', 'referral', 'revenue'];
  const stageLabels: { [key: string]: string } = {
    acquisition: 'Acquisition',
    activation: 'Activation',
    retention: 'Retention',
    referral: 'Referral',
    revenue: 'Revenue'
  };

  return stages.map((stageName, index) => {
    const stage = (metrics.stages as any)[stageName];
    if (!stage) return null;

    const hasGaps = stage.metrics?.some((m: any) =>
      m.gap && !isNegativeGap(m.gap) &&
      (m.gap.rate !== 0 || m.gap.amount !== 0 || m.gap.percentage !== 0)
    );

    return (
      <React.Fragment key={stageName}>
        <div className={`stage ${hasGaps ? 'has-gaps' : 'on-track'}`}>
          <div className="stage-header">
            <h2>{stageLabels[stageName]}</h2>
            <p className="stage-goal">{stage.stage_goal}</p>
          </div>
          <div className="metrics">
            {stage.metrics?.map((metric: any, idx: number) => renderMetric(metric, viability, idx)) || null}
          </div>
        </div>
        {index < stages.length - 1 && <div className="connector">→</div>}
      </React.Fragment>
    );
  }).filter(Boolean);
}

function renderMetric(metric: any, viability: LeanViability | null, key: number): JSX.Element {
  const hasGap = metric.gap && !isNegativeGap(metric.gap);
  const gapClass = hasGap ? 'gap-exists' : 'on-track';

  const hasImport = viability && metric.target?.imported_from;
  const importAnchor = hasImport ? metric.target.imported_from.replace(/\./g, '-') : null;

  return (
    <div key={key} className={`metric ${gapClass}`}>
      <div className="metric-name">{metric.name}</div>
      {metric.description && <div className="metric-description">{metric.description}</div>}

      <div className="metric-values">
        {metric.target && (
          <div className="value-row">
            <span className="label">Target:</span>
            <span className={`value ${hasImport ? 'clickable' : ''}`}>
              {formatMetricValue(metric.target)}
              {hasImport && <span className="import-icon">↗</span>}
            </span>
          </div>
        )}
        {hasImport && <div className="import-note">From: {metric.target.imported_from}</div>}

        {metric.current && (
          <div className="value-row">
            <span className="label">Current:</span>
            <span className="value">{formatMetricValue(metric.current)}</span>
          </div>
        )}

        {metric.gap && (
          <div className="value-row gap-row">
            <span className="label">Gap:</span>
            <span className={`gap-value ${hasGap ? 'negative' : 'positive'}`}>{formatGap(metric.gap)}</span>
          </div>
        )}
      </div>
    </div>
  );
}

function formatMetricValue(value: any): string {
  if (value.rate !== undefined && value.period) {
    return `${value.rate}/${value.period}`;
  }
  if (value.amount !== undefined && value.currency) {
    return `${value.currency} ${value.amount.toLocaleString()}`;
  }
  if (value.percentage !== undefined) {
    return `${value.percentage}%`;
  }
  return 'N/A';
}

export default AARRRMetricsVisualizer;