commit a27537772f715082d358b405cbc24b039fcec7ef
Author: Maksymilian Piechota <maksymilian.piechota@gmail.com>
Date:   Fri Dec 26 15:50:01 2025 +0100

    feat: Complete React migration with Vite and interactive visualizations
    
    - Migrate from vanilla HTML to React with Vite build system
    - Add ReactFlow for interactive policy charter diagrams with hierarchical layout
    - Create React components for all business layer visualizations:
      * NorthStarVisualizer - Strategic vision and goals
      * LeanCanvasVisualizer - Business model canvas
      * LeanViabilityVisualizer - Financial calculations and targets
      * AARRRMetricsVisualizer - Customer acquisition metrics
      * PolicyCharterVisualizer - Interactive node-based strategy diagram
      * TraceabilityVisualizer - Business architecture relationships
    - Implement tree-based layout algorithm preventing arrow crossings
    - Add real business blueprint data loading from YAML files
    - Configure proper spacing and positioning for clean visual hierarchy
    - Position risks at bottom level as foundation concerns
    - Include comprehensive legend and interactive controls
    - Copy examples to public directory for client-side data loading

diff --git a/src/components/PolicyCharterVisualizer.tsx b/src/components/PolicyCharterVisualizer.tsx
new file mode 100644
index 0000000..611cbb5
--- /dev/null
+++ b/src/components/PolicyCharterVisualizer.tsx
@@ -0,0 +1,416 @@
+import React, { useCallback, useMemo } from 'react';
+import ReactFlow, {
+  Node,
+  Edge,
+  Background,
+  Controls,
+  MiniMap,
+  useNodesState,
+  useEdgesState,
+  addEdge,
+  Connection,
+  EdgeChange,
+  NodeChange,
+} from 'reactflow';
+import 'reactflow/dist/style.css';
+import { PolicyCharter } from '../parser/types';
+
+interface PolicyCharterVisualizerProps {
+  charter: PolicyCharter;
+}
+
+const PolicyCharterVisualizer: React.FC<PolicyCharterVisualizerProps> = ({ charter }) => {
+  const initialNodes: Node[] = useMemo(() => {
+    const nodes: Node[] = [];
+    const levelSpacing = 280; // Increased spacing between levels
+    const nodeWidth = 250;
+    const horizontalSpacing = 100; // Extra spacing between nodes in same level
+
+    // Calculate layout dimensions
+    const goals = charter.goals || [];
+    const tactics = charter.tactics || [];
+    const policies = charter.policies || [];
+    const risks = charter.risks || [];
+
+    // Create a tree structure to organize nodes
+    const treeStructure: { [key: string]: { tactics: any[], policies: any[], width: number } } = {};
+
+    // Initialize goals in tree
+    goals.forEach(goal => {
+      treeStructure[goal.id] = {
+        tactics: tactics.filter(tactic => goal.tactics?.includes(tactic.id)) || [],
+        policies: [],
+        width: 0
+      };
+    });
+
+    // Add policies to tactics
+    tactics.forEach(tactic => {
+      const tacticPolicies = policies.filter(policy => tactic.drives_policies?.includes(policy.id)) || [];
+      const parentGoal = goals.find(goal => goal.tactics?.includes(tactic.id));
+      if (parentGoal) {
+        treeStructure[parentGoal.id].policies.push(...tacticPolicies);
+      }
+    });
+
+    // Calculate widths for each goal branch (with more spacing)
+    goals.forEach(goal => {
+      const branch = treeStructure[goal.id];
+      const tacticsCount = Math.max(branch.tactics.length, 1);
+      const policiesCount = Math.max(branch.policies.length, 1);
+      const risksCount = risks.length;
+      branch.width = Math.max(
+        tacticsCount * (nodeWidth + horizontalSpacing),
+        policiesCount * (nodeWidth + horizontalSpacing),
+        risksCount > 0 ? risksCount * (nodeWidth + horizontalSpacing) : 0
+      );
+    });
+
+    // Position goals at the top (Level 0) - evenly distributed with more spacing
+    let currentX = 0;
+    goals.forEach((goal, index) => {
+      const branchWidth = treeStructure[goal.id].width;
+      const x = currentX + branchWidth / 2 - nodeWidth / 2;
+
+      nodes.push({
+        id: goal.id,
+        type: 'default',
+        position: { x, y: 50 },
+        data: {
+          label: (
+            <div className="node-content">
+              <div className="node-type">Goal</div>
+              <div className="node-title">{goal.title}</div>
+              <div className="node-description">{goal.description}</div>
+            </div>
+          ),
+        },
+        style: { background: '#e3f2fd', border: '2px solid #2196f3', borderRadius: '8px', width: nodeWidth },
+      });
+
+      currentX += branchWidth + 150; // Increased spacing between branches
+    });
+
+    // Position tactics (Level 1) - centered under their parent goals with more spacing
+    goals.forEach((goal) => {
+      const branch = treeStructure[goal.id];
+      const goalNode = nodes.find(n => n.id === goal.id);
+      if (!goalNode) return;
+
+      const goalCenterX = goalNode.position.x + nodeWidth / 2;
+      const tacticsCount = branch.tactics.length;
+
+      branch.tactics.forEach((tactic, tacticIndex) => {
+        let tacticX;
+        if (tacticsCount === 1) {
+          tacticX = goalCenterX - nodeWidth / 2;
+        } else {
+          const totalWidth = (tacticsCount - 1) * (nodeWidth + horizontalSpacing);
+          const startX = goalCenterX - totalWidth / 2;
+          tacticX = startX + tacticIndex * (nodeWidth + horizontalSpacing);
+        }
+
+        nodes.push({
+          id: tactic.id,
+          type: 'default',
+          position: { x: tacticX, y: 50 + levelSpacing },
+          data: {
+            label: (
+              <div className="node-content">
+                <div className="node-type">Tactic</div>
+                <div className="node-title">{tactic.title}</div>
+                <div className="node-description">{tactic.description}</div>
+              </div>
+            ),
+          },
+          style: { background: '#f3e5f5', border: '2px solid #9c27b0', borderRadius: '8px', width: nodeWidth },
+        });
+      });
+    });
+
+    // Position policies (Level 2) - under their driving tactics with more spacing
+    goals.forEach((goal) => {
+      const branch = treeStructure[goal.id];
+      const goalNode = nodes.find(n => n.id === goal.id);
+      if (!goalNode) return;
+
+      const goalCenterX = goalNode.position.x + nodeWidth / 2;
+      const policiesCount = branch.policies.length;
+
+      if (policiesCount > 0) {
+        branch.policies.forEach((policy, policyIndex) => {
+          let policyX;
+          if (policiesCount === 1) {
+            policyX = goalCenterX - nodeWidth / 2;
+          } else {
+            const totalWidth = (policiesCount - 1) * (nodeWidth + horizontalSpacing);
+            const startX = goalCenterX - totalWidth / 2;
+            policyX = startX + policyIndex * (nodeWidth + horizontalSpacing);
+          }
+
+          nodes.push({
+            id: policy.id,
+            type: 'default',
+            position: { x: policyX, y: 50 + levelSpacing * 2 },
+            data: {
+              label: (
+                <div className="node-content">
+                  <div className="node-type">Policy</div>
+                  <div className="node-title">{policy.title}</div>
+                  <div className="node-description">{policy.rule}</div>
+                </div>
+              ),
+            },
+            style: { background: '#fff3e0', border: '2px solid #ff9800', borderRadius: '8px', width: nodeWidth },
+          });
+        });
+      }
+    });
+
+    // Position risks at the bottom (Level 3) - horizontally distributed
+    if (risks.length > 0) {
+      const totalWidth = (risks.length - 1) * (nodeWidth + horizontalSpacing);
+      const startX = (currentX - 150 - totalWidth) / 2; // Center risks across total width
+
+      risks.forEach((risk, index) => {
+        const riskX = startX + index * (nodeWidth + horizontalSpacing);
+
+        nodes.push({
+          id: risk.id,
+          type: 'default',
+          position: { x: riskX, y: 50 + levelSpacing * 3 },
+          data: {
+            label: (
+              <div className="node-content">
+                <div className="node-type">Risk</div>
+                <div className="node-title">{risk.description}</div>
+                <div className="node-description">P: {risk.probability} | I: {risk.impact}</div>
+              </div>
+            ),
+          },
+          style: { background: '#ffebee', border: '2px solid #f44336', borderRadius: '8px', width: nodeWidth },
+        });
+      });
+    }
+
+    return nodes;
+  }, [charter]);
+
+  const initialEdges: Edge[] = useMemo(() => {
+    const edges: Edge[] = [];
+
+    // Connect goals to tactics
+    charter.goals?.forEach((goal) => {
+      goal.tactics?.forEach((tacticId) => {
+        edges.push({
+          id: `${goal.id}-${tacticId}`,
+          source: goal.id,
+          target: tacticId,
+          type: 'smoothstep',
+          style: { stroke: '#2196f3', strokeWidth: 2 },
+        });
+      });
+    });
+
+    // Connect tactics to policies
+    charter.tactics?.forEach((tactic) => {
+      tactic.drives_policies?.forEach((policyId) => {
+        edges.push({
+          id: `${tactic.id}-${policyId}`,
+          source: tactic.id,
+          target: policyId,
+          type: 'smoothstep',
+          style: { stroke: '#9c27b0', strokeWidth: 2 },
+        });
+      });
+    });
+
+    // Connect policies to risks (mitigation relationships)
+    charter.policies?.forEach((policy) => {
+      charter.risks?.forEach((risk) => {
+        if (risk.mitigation?.includes(policy.id)) {
+          edges.push({
+            id: `${policy.id}-${risk.id}`,
+            source: policy.id,
+            target: risk.id,
+            type: 'smoothstep',
+            style: { stroke: '#f44336', strokeWidth: 2, strokeDasharray: '5,5' },
+            label: 'mitigates',
+          });
+        }
+      });
+    });
+
+    // KPI connections hidden for now
+    // charter.kpis?.forEach((kpi) => {
+    //   charter.goals?.forEach((goal) => {
+    //     if (kpi.justification?.startsWith('aaarr.') && goal.aaarr_impact?.some(impact => kpi.justification?.includes(impact))) {
+    //       edges.push({
+    //         id: `${kpi.id}-${goal.id}`,
+    //         source: kpi.id,
+    //         target: goal.id,
+    //         type: 'smoothstep',
+    //         style: { stroke: '#4caf50', strokeWidth: 2 },
+    //         label: 'measures',
+    //       });
+    //     }
+    //   });
+    // });
+
+    return edges;
+  }, [charter]);
+
+  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
+  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);
+
+  const onConnect = useCallback(
+    (params: Connection) => setEdges((eds) => addEdge(params, eds)),
+    [setEdges]
+  );
+
+  return (
+    <div className="container">
+      <header>
+        <h1>{charter.title}</h1>
+        <div className="meta">
+          <span>Version: {charter.version}</span>
+          <span>Last Updated: {charter.last_updated}</span>
+        </div>
+      </header>
+
+      <div className="policy-flow">
+        <div className="flow-container">
+          <ReactFlow
+            nodes={nodes}
+            edges={edges}
+            onNodesChange={onNodesChange}
+            onEdgesChange={onEdgesChange}
+            onConnect={onConnect}
+            fitView
+            attributionPosition="bottom-left"
+          >
+            <Background />
+            <Controls />
+            <MiniMap />
+          </ReactFlow>
+        </div>
+
+        <div className="legend">
+          <h3>Legend</h3>
+          <div className="legend-items">
+            <div className="legend-item">
+              <div className="legend-color" style={{ background: '#e3f2fd', border: '2px solid #2196f3' }}></div>
+              <span>Goals - Strategic objectives</span>
+            </div>
+            <div className="legend-item">
+              <div className="legend-color" style={{ background: '#f3e5f5', border: '2px solid #9c27b0' }}></div>
+              <span>Tactics - Implementation approaches</span>
+            </div>
+            <div className="legend-item">
+              <div className="legend-color" style={{ background: '#fff3e0', border: '2px solid #ff9800' }}></div>
+              <span>Policies - Specific rules and procedures</span>
+            </div>
+            <div className="legend-item">
+              <div className="legend-color" style={{ background: '#ffebee', border: '2px solid #f44336' }}></div>
+              <span>Risks - Potential issues and mitigations</span>
+            </div>
+            {/* KPIs hidden for now */}
+            {/* <div className="legend-item">
+              <div className="legend-color" style={{ background: '#e8f5e8', border: '2px solid #4caf50' }}></div>
+              <span>KPIs - Key performance indicators</span>
+            </div> */}
+            <div className="legend-item connection">
+              <div className="legend-line solid" style={{ background: '#666' }}></div>
+              <span>Direct relationships</span>
+            </div>
+            <div className="legend-item connection">
+              <div className="legend-line dashed" style={{ background: 'repeating-linear-gradient(90deg, #f44336, #f44336 5px, transparent 5px, transparent 10px)' }}></div>
+              <span>Risk mitigation</span>
+            </div>
+          </div>
+        </div>
+      </div>
+
+      <footer>
+        <p>Generated by BLUEPRINT - Business Layer Architecture</p>
+      </footer>
+
+      <style jsx>{`
+        .container { max-width: 1400px; margin: 0 auto; background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
+        header { padding: 2rem; border-bottom: 2px solid #e2e8f0; }
+        h1 { font-size: 2.5rem; margin-bottom: 0.5rem; color: #1a1a1a; }
+        .meta { color: #666; font-size: 0.9rem; }
+        .meta span { margin-right: 2rem; }
+
+        .policy-flow { margin: 2rem 0; }
+        .flow-container { height: 600px; border: 1px solid #e2e8f0; border-radius: 8px; }
+
+        .node-content {
+          padding: 8px;
+          max-width: 200px;
+        }
+        .node-type {
+          font-size: 10px;
+          font-weight: bold;
+          text-transform: uppercase;
+          color: #666;
+          margin-bottom: 4px;
+        }
+        .node-title {
+          font-size: 12px;
+          font-weight: bold;
+          margin-bottom: 4px;
+          line-height: 1.3;
+        }
+        .node-description {
+          font-size: 10px;
+          color: #666;
+          line-height: 1.2;
+        }
+
+        .legend {
+          margin-top: 2rem;
+          padding: 1.5rem;
+          background: #f8f9fa;
+          border-radius: 8px;
+        }
+        .legend h3 {
+          margin: 0 0 1rem 0;
+          color: #1a202c;
+          font-size: 1.1rem;
+        }
+        .legend-items {
+          display: grid;
+          grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
+          gap: 0.75rem;
+        }
+        .legend-item {
+          display: flex;
+          align-items: center;
+          gap: 0.75rem;
+        }
+        .legend-color {
+          width: 20px;
+          height: 20px;
+          border-radius: 4px;
+          flex-shrink: 0;
+        }
+        .legend-line {
+          width: 20px;
+          height: 2px;
+          flex-shrink: 0;
+        }
+        .legend-line.solid { height: 2px; }
+        .legend-line.dashed { height: 2px; }
+
+        .connection .legend-line {
+          height: 2px;
+        }
+
+        footer { padding: 2rem; border-top: 1px solid #e2e8f0; color: #666; font-size: 0.9rem; text-align: center; }
+      `}</style>
+    </div>
+  );
+};
+
+export default PolicyCharterVisualizer;
\ No newline at end of file
